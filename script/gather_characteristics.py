from collections import deque
import csv
import getopt
import sys
import pandas as pd
from time import time

CONTEXT_TIME = 0.2


def update_deques(bef, q_bef, aft, q_aft, cur, df):
    """
    Update the before and after deques for the current element so that they contain all
    packets within CONTEXT_TIME seconds of cur
    :param bef: index of packet CONTEXT_TIME seconds before packet cur-1
    :param q_bef: deque before current index
    :param aft: index of packet CONTEXT_TIME seconds after packet cur-1
    :param q_aft: deque containing all packets within CONTEXT_TIME after cur-1
    :param cur: current packet
    :return: bef, q_bef, aft, q_aft for packet cur instead of cur-1
    """
    # print("qbef before is: ",q_bef)
    # print(cur, "/", len(df))

    if cur > 0:
        q_bef.append(df.loc[cur-1,:])

    try:
        q_aft.popleft()
    except:
        pass

    while df.loc[cur,:].time - df.loc[bef+1,:].time > CONTEXT_TIME:
        # print(cur, bef, aft)
        # print(df.loc[cur,:].time, df.loc[bef+1,:].time)
        bef +=1
        try:
            q_bef.popleft()
        except:
            pass

    if aft + 1 < len(df):
        while df.loc[aft+1,:].time - df.loc[cur,:].time < CONTEXT_TIME:
            # print(cur, bef, aft)
            # print(df.loc[aft+1,:].time, df.loc[cur,:].time, df.loc[aft+1,:].time - df.loc[cur,:].time)
            aft += 1
            q_aft.append(df.loc[aft,:])
            if aft + 1 >= len(df):
                break
    print(cur,bef,aft)
    print(aft - bef)
    return bef, q_bef, aft, q_aft


def relative_chars_from_row(cur, q_bef, q_aft):
    rel_chars = {'same_src': 0,
                 'same_dst': 0,
                 'same_seq': 0,
                 'same_tsport': 0,
                 'same_tdport': 0,
                 'same_usport': 0,
                 'same_udport': 0,
                 'same_tflags': 0
                 }
    # print("qbef = ", q_bef)
    for row in q_bef:
        if cur.src == row.src:
            rel_chars['same_src'] += 1
        if cur.dst == row.dst:
            rel_chars['same_dst'] += 1
        if cur.seq == row.seq:
            rel_chars['same_seq'] += 1
        if cur.tsport == row.tsport:
            rel_chars['same_tsport'] += 1
        if cur.tdport == row.tdport:
            rel_chars['same_tdport'] += 1
        if cur.usport == row.usport:
            rel_chars['same_usport'] += 1
        if cur.udport == row.udport:
            rel_chars['same_udport'] += 1
        if cur.tflags == row.tflags:
            rel_chars['same_tflags'] += 1

    for row in q_aft:
        if cur.src == row.src:
            rel_chars['same_src'] += 1
        if cur.dst == row.dst:
            rel_chars['same_dst'] += 1
        if cur.seq == row.seq:
            rel_chars['same_seq'] += 1
        if cur.tsport == row.tsport:
            rel_chars['same_tsport'] += 1
        if cur.tdport == row.tdport:
            rel_chars['same_tdport'] += 1
        if cur.usport == row.usport:
            rel_chars['same_usport'] += 1
        if cur.udport == row.udport:
            rel_chars['same_udport'] += 1
        if cur.tflags == row.tflags:
            rel_chars['same_tflags'] += 1
    return rel_chars


def chars_in_time_frame(df):
    characteristics = pd.DataFrame(columns=['ip_version', 'ihl', 'tos', 'ilen', 'id', 'iflags', 'frag', 'ttl', 'proto',
                                            'ichksum', 'same_src', 'same_dst', 'ioptions', 'tsport', 'tdport',
                                            'same_tsport', 'same_tdport', 'same_seq', 'dataofs', 'reserved',
                                            'same_tflags', 'tflag_fin', 'tflag_syn', 'tflag_rst', 'tflag_psh',
                                            'tflag_ack', 'tflag_urg', 'tflag_ece', 'tflag_cwr', 'window', 'tchksum',
                                            'urgptr', 'usport', 'udport',
                                            'same_usport', 'same_udport', 'ulen', 'uchksum','data_class'])
    queue_before = deque()
    queue_after = deque()
    before_index = after_index = 0
    starting_time = df.time[0]

    while df.time[after_index]-starting_time < CONTEXT_TIME:
        queue_after.append(df.loc[after_index,:])
        if after_index < len(df):
            after_index += 1
        else:
            break

    for cur_el, row in df.iterrows():
        before_index, queue_before, after_index, queue_after = update_deques(before_index, queue_before,
                                                                             after_index, queue_after, cur_el, df)
        rc = relative_chars_from_row(df.loc[cur_el,:], queue_before, queue_after)

        # print(rc['same_src'])
        # print()
        characteristics.loc[cur_el,:] = [row.ip_version, row.ihl, row.tos, row.ilen, row.id, row.iflags, row.frag,
                                         row.ttl,row.proto, row.ichksum, rc['same_src'], rc['same_dst'], row.ioptions,
                                         row.tsport, row.tdport, rc['same_tsport'], rc['same_tdport'], rc['same_seq'],
                                         row.dataofs, row.reserved, rc['same_tflags'], row.tflag_fin, row.tflag_syn,
                                         row.tflag_rst, row.tflag_psh, row.tflag_ack, row.tflag_urg, row.tflag_ece,
                                         row.tflag_cwr, row.window, row.tchksum, row.urgptr, row.usport, row.udport,
                                         rc['same_usport'], rc['same_udport'], row.ulen, row.uchksum, row.data_class]

    return characteristics

def import_csv(infile):
    df = pd.read_csv(infile)
    return df


def main(argv):
    """
    This script parses network metadata characteristics from the pcap and creates an output file with each line
    corresponding to a single network packet. Besides the characteristics, each line contains a class at the end
    which can be used to train a machine learning model.
    :param argv: The arguments for this script are -i infile, -o outfile and -c class
    :return:
    """

    # infile = "../captures/dirb/sheffield_dirb_york_flags_2000.csv"
    # outfile = "../captures/dirb/sheffield_dirb_york_flags_2000_characteristics_fixed.csv"
    # infile = "../captures/nmap_sS/sheffield_nmap_sS_flags_2000.csv"
    # outfile = "../captures/nmap_sS/sheffield_nmap_sS_flags_2000_characteristics_fixed.csv"
    # infile = "../captures/nmap_sA/sheffield_nmap_sA_flags_2000.csv"
    # outfile = "../captures/nmap_sA/sheffield_nmap_sA_flags_2000_characteristics_fixed.csv"
    # infile = "../captures/nmap_sT/sheffield_nmap_sT_flags_2000.csv"
    # outfile = "../captures/nmap_sT/sheffield_nmap_sT_flags_2000_characteristics_fixed.csv"
    # infile = "../captures/ssh/sheffield_ssh_timed.csv"
    # outfile = "../captures/ssh/sheffield_ssh_characteristics_fixed.csv"
    infile = "../captures/nmap_sS/scanme_nmap_sS.csv"
    outfile = "../captures/nmap_sS/scanme_nmap_sS_characteristics_fixed.csv"

    t0 = time()

    try:
        opts, args = getopt.getopt(argv, "i:o:c:")
    except getopt.GetoptError:
        print
        'gather_characteristics.py -i <infile.csv> -o <outfile.csv>'
        sys.exit(2)
    for opt, arg in opts:
        if opt == '-i':
            infile = arg
        elif opt == "-o":
            outfile = arg

    df = import_csv(infile)
    characteristics = chars_in_time_frame(df)
    characteristics.to_csv(outfile)

    t1 = time()
    print(t1-t0)
    return


if __name__ == "__main__":
    main(sys.argv[1:])
