import csv
import getopt
import sys
from time import time

from scapy.all import *

import pandas as pd
from scapy.utils import RawPcapReader
from scapy.layers.l2 import Ether

from scapy.layers.inet import IP, TCP, UDP


def printable_timestamp(ts, resol):
    """
    Source: https://vnetman.github.io/pcap/python/pyshark/scapy/libpcap/2018/10/25/analyzing-packet-captures-with-python-part-1.html
    :param ts: timestamp
    :param resol: Resolution, either 1000000 (microsecond) or 1000000000 (nanosecond)
    :return:
    """
    ts_sec = ts // resol
    ts_subsec = ts % resol
    ts_sec_str = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(ts_sec))
    return '{}.{}'.format(ts_sec_str, ts_subsec)


def process_pcap(file_name):
    """
    Parse the pcap as a list of characteristics for each packet.
    :param infile: the pcap file that contains
    :return: the network traffic parsed as characteristics in ... format
    """
    print('Opening {}...'.format(file_name))

    pkts = rdpcap(file_name)
    processed_packets = []

    for index, pkt in enumerate(pkts):
        if index >= 2000:
            break
        characteristics = []

        # General characteristics
        time = pkt.time

        # IP characteristics
        ip_version = ihl = tos = ilen = id = iflags = frag = ttl = proto = ichksum = src = dst = ioptions = ""

        # TCP characteristics
        tsport = tdport = seq = ack = dataofs = reserved = window = tflags = tchksum = urgptr = toptions = ""
        tflag_fin = tflag_syn = tflag_rst = tflag_psh = tflag_ack = tflag_urg = tflag_ece = tflag_cwr = ""

        # UDP characteristics
        usport = udport = ulen = uchksum = ""

        #Gather IP packet statistics
        if IP in pkt:
            ip_version = pkt[IP].version
            ihl = pkt[IP].ihl
            tos = pkt[IP].tos
            ilen = pkt[IP].len
            id = pkt[IP].id
            iflags = pkt[IP].flags
            frag = pkt[IP].frag
            ttl = pkt[IP].ttl
            proto = pkt[IP].proto
            ichksum = pkt[IP].chksum
            src = pkt[IP].src
            dst = pkt[IP].dst
            ioptions = pkt[IP].options
        #Gather TCP packet statistics
        if TCP in pkt:
            tsport = pkt[TCP].sport
            tdport = pkt[TCP].dport
            seq = pkt[TCP].seq
            ack = pkt[TCP].ack
            dataofs = pkt[TCP].dataofs
            reserved = pkt[TCP].reserved
            tflag_fin = 1 if 0x01 & pkt[TCP].flags.value else 0
            tflag_syn = 1 if 0x02 & pkt[TCP].flags.value else 0
            tflag_rst = 1 if 0x04 & pkt[TCP].flags.value else 0
            tflag_psh = 1 if 0x08 & pkt[TCP].flags.value else 0
            tflag_ack = 1 if 0x10 & pkt[TCP].flags.value else 0
            tflag_urg = 1 if 0x20 & pkt[TCP].flags.value else 0
            tflag_ece = 1 if 0x40 & pkt[TCP].flags.value else 0
            tflag_cwr = 1 if 0x80 & pkt[TCP].flags.value else 0
            tflags = pkt[TCP].flags
            window = pkt[TCP].window
            tchksum = pkt[TCP].chksum
            urgptr = pkt[TCP].urgptr
            toptions = pkt[TCP].options
        #Gather UDP packet statistics
        if UDP in pkt:
            usport = pkt[UDP].sport
            udport = pkt[UDP].dport
            ulen = pkt[UDP].len
            uchksum = pkt[UDP].chksum

        characteristics.extend([time, ip_version, ihl, tos, ilen, id, iflags, frag, ttl, proto, ichksum, src, dst,
                                ioptions, tsport, tdport, seq, ack, dataofs, reserved, tflags, tflag_fin, tflag_syn,
                                tflag_rst, tflag_psh, tflag_ack, tflag_urg, tflag_ece, tflag_cwr, window, tchksum, urgptr,
                                # toptions,
                                usport, udport, ulen, uchksum])
        processed_packets.append(characteristics)
    return processed_packets


def write_csv(processed_packets, data_class, outfile):
    """
    :param processed_packets:
    :param data_class:
    :param outfile:
    :return:
    """
    with open(outfile, 'w') as myfile:
        wr = csv.writer(myfile)
        titles = ["time","ip_version","ihl","tos","ilen","id","iflags","frag","ttl","proto","ichksum","src","dst",
                  "ioptions","tsport","tdport","seq","ack","dataofs","reserved","tflags","tflag_fin", "tflag_syn",
                  "tflag_rst", "tflag_psh", "tflag_ack", "tflag_urg", "tflag_ece", "tflag_cwr","window","tchksum","urgptr",
                  #"toptions",
                  "usport","udport","ulen","uchksum","data_class"]
        # print(titles)
        wr.writerow(titles)
        for row in processed_packets:
            # print((row + [data_class]))
            wr.writerow(row + [data_class])


def main(argv):
    """
    This script parses network metadata characteristics from the pcap & creates an output file with each line
    corresponding to a single network packet. Besides the characteristics, each line contains a class at the end
    which can be used to train a machine learning model.
    :param argv: The arguments for this script are -i infile, -o outfile & -c class
    :return:
    """
    # infile = "../captures/dirb/sheffield_dirb_york.pcap"
    # outfile = "../captures/dirb/sheffield_dirb_york_flags_2000.csv"
    # infile = "../captures/nmap_sS/sheffield_nmap_syn_3.pcap"
    # outfile = "../captures/nmap_sS/sheffield_nmap_sS_flags_2000.csv"
    # infile = "../captures/nmap_sA/sheffield_nmap_ack.pcap"
    # outfile = "../captures/nmap_sA/sheffield_nmap_sA_flags_2000.csv"
    # infile = "../captures/nmap_sT/sheffield_nmap_connect.pcap"
    # outfile = "../captures/nmap_sT/sheffield_nmap_sT_flags_2000.csv"
    # infile = "../captures/ssh/sheffield_ssh.pcap"
    # outfile = "../captures/ssh/sheffield_ssh_timed.csv"
    infile = "../captures/nmap_sS/scanme_nmap_sS.pcap"
    outfile = "../captures/nmap_sS/scanme_nmap_sS.csv"

    t0 = time.time()

    data_class = "ssh"
    try:
        opts, args = getopt.getopt(argv, "i:o:c:")
    except getopt.GetoptError:
        print
        'pcap_parser.py -i <infile.pcap> -o <outfile.csv>'
        sys.exit(2)
    for opt, arg in opts:
        if opt == '-i':
            infile = arg
        elif opt == "-o":
            outfile = arg
        elif opt == "-c":
            data_class = arg

    network_data = process_pcap(infile)
    print(len(network_data))

    write_csv(network_data, data_class, outfile)

    t1 = time.time()
    print(t1 - t0)

    return


if __name__ == "__main__":
    main(sys.argv[1:])
